
{-|
Module      : AI
Description : Implementation of AI player based on the MCTS algorithm
-}
module AI (
    Hiperparameters (..),
    Generator (..),
    newGenerator,
    getNextMove
) where

import Game
import System.Random

-- | Type representing MCTS algorithm hiperparameters
type Hiperparameters = Int

-- | Random number generator state used by the AI algorithm.
type Generator = StdGen

-- | For a given seed returns new generator.
newGenerator :: Int -> Generator
newGenerator = mkStdGen

-- | Returns a completly random move when only there is one possible.
getRandomMove :: RandomGen g => GameState -> g -> (Maybe Move, g)
getRandomMove gameState generator =
    (Just (moves !! rand), nextGenerator)
    where
        moves = Game.availableMoves gameState
        (rand, nextGenerator) = randomR (0, ((length moves) - 1)) generator

-- | Simulate one random playout. 
-- | Takes game state - a starting state for the simulation and a random generator.
-- | Returns who wins the playout - Just Red / Just Blue / Nothing when its a draw
-- | Tail recursive and strict.
-- | TODO dyskontowanie odległych wypłat?
simulation :: RandomGen g => GameState -> g -> (Maybe Player, g)
simulation gameState g = 
    case Game.whoWins gameState of
        Nothing -> -- No one won yet
            let 
                (maybeMove, nextGen) = getRandomMove gameState g
            in
                case maybeMove of 
                    Nothing -> (Nothing, -- there are no possible moves from this state so its a draw
                                g) -- generator can be either changed or unchanged - we tried to generate moves but did not go deeper into the game tree
                    Just move -> 
                        case Game.applyMove gameState move of
                            Nothing -> (Nothing, g) -- this should not happen because if move is generated by random move generator it should be a valid move
                            Just nextState -> -- there are possible further moves so we simulate further
                                --simulation nextState nextGen 
                                seq (nextState, nextGen) $ simulation nextState nextGen -- we use seq to make it strict
        Just winner -> (Just winner, g) -- Someone already wins in that state, there is no need for further simulation, we did not generate any moves so generator is unchanged



-- | Returns next move of the AI player.
getNextMove :: RandomGen g 
    -- | Game state to which AI player should respond
    => GameState 
    -- | MCTS algorithm hiperparameters
    -> Hiperparameters 
    -- | Random number generator state
    -> g 
    -- | If there is a move possible then Just Move, if there is no move possible Nothing
    -> (Maybe Move, 
    -- | State of the random number generator after calculating the move.
    g)
getNextMove gameState _ generator =
    getRandomMove gameState generator
    
            
        